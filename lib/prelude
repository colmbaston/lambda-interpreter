~~ Basic Combinators

~let S := λx.λy.λz.x z (y z)
~let K := λx.λy.x
~let I := λx.x
~let B := λx.λy.λz.x (y z)
~let C := λx.λy.λz.x z y
~let W := λx.λy.x y y
~let X := λx.x S K

~~ Booleans

~let True  := λt.λf.t
~let False := λt.λf.f

~let Not := λb.b False True
~let And := λa.λb.a b False
~let Or  := λa.λb.a True b
~let Xor := λa.λb.a (Not b) b

~~ Church Numeral Operations

~let IsZero := λn.n (λx.False) True
~let Succ   := λn.λf.λx.f (n f x)
~let Pred   := λn.λf.λx.n (λg.λh.h (g f)) (λu.x) (λu.u)
~let Add    := λm.λn.λf.λx.m f (n f x)
~let Sub    := λm.λn.n Pred m
~let Mul    := λm.λn.λf.m (n f)
~let Exp    := λm.λn.(IsZero n) 1 (n m)

~let LEQ := λm.λn.IsZero (Sub m n)
~let GEQ := λm.λn.IsZero (Sub n m)
~let LT  := λm.λn.Not (GEQ m n)
~let GT  := λm.λn.Not (LEQ m n)
~let EQ  := λm.λn.And (GEQ m n) (LEQ m n)
~let NEQ := λm.λn.Not (EQ m n)

~let Min := λn.λm.LEQ n m n m
~let Max := λn.λm.GEQ n m n m

~~ Pairs

~let Pair := λa.λb.λp.p a b

~let First  := λp.p True
~let Second := λp.p False
~let Swap   := λp.Pair (Second p) (First p)

~~ Lists

~let Nil  := λx.True
~let Cons := Pair
~let Head := First
~let Tail := Second

~let Null  := λl.l (λh.λt.False)
~let Drop  := λn.n Tail
~let Index := λl.λn.Head (Drop n l)

~~ Fixed-point Combinators

~let Y     := λf.(λx.f (x x)) (λx.f (x x))
~let Z     := λf.(λx.f (λy.x x y)) (λx.f (λy.x x y))
~let Theta := (λx.λy.y (x x y)) (λx.λy.y (x x y))

~~ Recursion (Warning: These will diverge under applicative order reduction)

~let Fac    := Y (λr.λn.(IsZero n) 1 (Mul n (r (Pred n))))
~let DivMod := Y (λr.λq.λm.λn.(LT m n) (Pair q m) (r (Succ q) (Sub m n) n)) 0

~let Div := λm.λn.First (DivMod m n)
~let Mod := λm.λn.Second (DivMod m n)

~let Take  := Y (λr.λn.λl.(IsZero n) Nil (Cons (Head l) (r (Pred n) (Tail l))))
~let Foldr := λf.λx.Y (λr.λl.Null l x (f (Head l) (r (Tail l))))
~let Foldl := λf.Y (λr.λa.λl.(Null l) a (r (f (Head l) a) (Tail l)))

~let Sum     := Foldr (λh.λr.Add h r) 0
~let Length  := Foldr (λh.λr.Succ r) 0
~let Append  := λa.λb.Foldr (λh.λr.Cons h r) b a
~let Concat  := Foldr (λh.λr.Append h r) Nil
~let Map     := λf.Foldr (λh.λr.Cons (f h) r) Nil
~let Filter  := λp.Foldr (λh.λr.(p h) (Cons h r) r) Nil
~let Reverse := Foldl (λh.λa.Cons h a) Nil

~let Iterate := Y (λr.λf.λx.Cons x (r f (f x)))
~let From    := Iterate Succ

~let FilterPrime := λr.λxs.Cons (Head xs) (r (Filter (λn.Not (IsZero (Mod n (Head xs)))) (Tail xs)))
~let Primes      := Cons 2 (Y FilterPrime (Iterate (λx.Succ (Succ x)) 3))

~~ Mutual Recursion

~let REven := λr.λn.(IsZero n) True (r (Pred n))
~let ROdd  := λr.λn.(IsZero n) False (r (Pred n))

~let Even := Y (λx.REven (ROdd x))
~let Odd  := Y (λx.ROdd (REven x))
